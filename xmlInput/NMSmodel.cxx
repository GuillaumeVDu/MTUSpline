// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "NMSmodel.hxx"

// MuscleType
// 

const MuscleType::name_type& MuscleType::
name () const
{
  return this->name_.get ();
}

MuscleType::name_type& MuscleType::
name ()
{
  return this->name_.get ();
}

void MuscleType::
name (const name_type& x)
{
  this->name_.set (x);
}

void MuscleType::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const MuscleType::C1_type& MuscleType::
C1 () const
{
  return this->C1_.get ();
}

MuscleType::C1_type& MuscleType::
C1 ()
{
  return this->C1_.get ();
}

void MuscleType::
C1 (const C1_type& x)
{
  this->C1_.set (x);
}

const MuscleType::C2_type& MuscleType::
C2 () const
{
  return this->C2_.get ();
}

MuscleType::C2_type& MuscleType::
C2 ()
{
  return this->C2_.get ();
}

void MuscleType::
C2 (const C2_type& x)
{
  this->C2_.set (x);
}

const MuscleType::shapeFactor_type& MuscleType::
shapeFactor () const
{
  return this->shapeFactor_.get ();
}

MuscleType::shapeFactor_type& MuscleType::
shapeFactor ()
{
  return this->shapeFactor_.get ();
}

void MuscleType::
shapeFactor (const shapeFactor_type& x)
{
  this->shapeFactor_.set (x);
}

const MuscleType::optimalFiberLength_type& MuscleType::
optimalFiberLength () const
{
  return this->optimalFiberLength_.get ();
}

MuscleType::optimalFiberLength_type& MuscleType::
optimalFiberLength ()
{
  return this->optimalFiberLength_.get ();
}

void MuscleType::
optimalFiberLength (const optimalFiberLength_type& x)
{
  this->optimalFiberLength_.set (x);
}

const MuscleType::pennationAngle_type& MuscleType::
pennationAngle () const
{
  return this->pennationAngle_.get ();
}

MuscleType::pennationAngle_type& MuscleType::
pennationAngle ()
{
  return this->pennationAngle_.get ();
}

void MuscleType::
pennationAngle (const pennationAngle_type& x)
{
  this->pennationAngle_.set (x);
}

const MuscleType::tendonSlackLength_type& MuscleType::
tendonSlackLength () const
{
  return this->tendonSlackLength_.get ();
}

MuscleType::tendonSlackLength_type& MuscleType::
tendonSlackLength ()
{
  return this->tendonSlackLength_.get ();
}

void MuscleType::
tendonSlackLength (const tendonSlackLength_type& x)
{
  this->tendonSlackLength_.set (x);
}

const MuscleType::maxIsometricForce_type& MuscleType::
maxIsometricForce () const
{
  return this->maxIsometricForce_.get ();
}

MuscleType::maxIsometricForce_type& MuscleType::
maxIsometricForce ()
{
  return this->maxIsometricForce_.get ();
}

void MuscleType::
maxIsometricForce (const maxIsometricForce_type& x)
{
  this->maxIsometricForce_.set (x);
}

const MuscleType::strengthCoefficient_type& MuscleType::
strengthCoefficient () const
{
  return this->strengthCoefficient_.get ();
}

MuscleType::strengthCoefficient_type& MuscleType::
strengthCoefficient ()
{
  return this->strengthCoefficient_.get ();
}

void MuscleType::
strengthCoefficient (const strengthCoefficient_type& x)
{
  this->strengthCoefficient_.set (x);
}


// MusclesType
// 

const MusclesType::muscle_sequence& MusclesType::
muscle () const
{
  return this->muscle_;
}

MusclesType::muscle_sequence& MusclesType::
muscle ()
{
  return this->muscle_;
}

void MusclesType::
muscle (const muscle_sequence& s)
{
  this->muscle_ = s;
}


// MuscleSequenceType
//

MuscleSequenceType::
MuscleSequenceType ()
: ::xsd::cxx::tree::list< ::xml_schema::string, char > (this)
{
}

MuscleSequenceType::
MuscleSequenceType (size_type n, const ::xml_schema::string& x)
: ::xsd::cxx::tree::list< ::xml_schema::string, char > (n, x, this)
{
}

MuscleSequenceType::
MuscleSequenceType (const MuscleSequenceType& o,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::simple_type (o, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::string, char > (o, f, this)
{
}

// ChannelType
// 

const ChannelType::name_type& ChannelType::
name () const
{
  return this->name_.get ();
}

ChannelType::name_type& ChannelType::
name ()
{
  return this->name_.get ();
}

void ChannelType::
name (const name_type& x)
{
  this->name_.set (x);
}

void ChannelType::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const ChannelType::muscleSequence_type& ChannelType::
muscleSequence () const
{
  return this->muscleSequence_.get ();
}

ChannelType::muscleSequence_type& ChannelType::
muscleSequence ()
{
  return this->muscleSequence_.get ();
}

void ChannelType::
muscleSequence (const muscleSequence_type& x)
{
  this->muscleSequence_.set (x);
}

void ChannelType::
muscleSequence (::std::auto_ptr< muscleSequence_type > x)
{
  this->muscleSequence_.set (x);
}


// ChannelsType
// 

const ChannelsType::Channel_sequence& ChannelsType::
Channel () const
{
  return this->Channel_;
}

ChannelsType::Channel_sequence& ChannelsType::
Channel ()
{
  return this->Channel_;
}

void ChannelsType::
Channel (const Channel_sequence& s)
{
  this->Channel_ = s;
}


// DoFType
// 

const DoFType::name_type& DoFType::
name () const
{
  return this->name_.get ();
}

DoFType::name_type& DoFType::
name ()
{
  return this->name_.get ();
}

void DoFType::
name (const name_type& x)
{
  this->name_.set (x);
}

void DoFType::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const DoFType::muscleSequence_type& DoFType::
muscleSequence () const
{
  return this->muscleSequence_.get ();
}

DoFType::muscleSequence_type& DoFType::
muscleSequence ()
{
  return this->muscleSequence_.get ();
}

void DoFType::
muscleSequence (const muscleSequence_type& x)
{
  this->muscleSequence_.set (x);
}

void DoFType::
muscleSequence (::std::auto_ptr< muscleSequence_type > x)
{
  this->muscleSequence_.set (x);
}


// DoFsType
// 

const DoFsType::DoF_sequence& DoFsType::
DoF () const
{
  return this->DoF_;
}

DoFsType::DoF_sequence& DoFsType::
DoF ()
{
  return this->DoF_;
}

void DoFsType::
DoF (const DoF_sequence& s)
{
  this->DoF_ = s;
}


// PointsSequenceType
//

PointsSequenceType::
PointsSequenceType ()
: ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > (this)
{
}

PointsSequenceType::
PointsSequenceType (size_type n, const ::xml_schema::double_& x)
: ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > (n, x, this)
{
}

PointsSequenceType::
PointsSequenceType (const PointsSequenceType& o,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::simple_type (o, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > (o, f, this)
{
}

// CurveType
// 

const CurveType::name_type& CurveType::
name () const
{
  return this->name_.get ();
}

CurveType::name_type& CurveType::
name ()
{
  return this->name_.get ();
}

void CurveType::
name (const name_type& x)
{
  this->name_.set (x);
}

void CurveType::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const CurveType::xPoints_type& CurveType::
xPoints () const
{
  return this->xPoints_.get ();
}

CurveType::xPoints_type& CurveType::
xPoints ()
{
  return this->xPoints_.get ();
}

void CurveType::
xPoints (const xPoints_type& x)
{
  this->xPoints_.set (x);
}

void CurveType::
xPoints (::std::auto_ptr< xPoints_type > x)
{
  this->xPoints_.set (x);
}

const CurveType::yPoints_type& CurveType::
yPoints () const
{
  return this->yPoints_.get ();
}

CurveType::yPoints_type& CurveType::
yPoints ()
{
  return this->yPoints_.get ();
}

void CurveType::
yPoints (const yPoints_type& x)
{
  this->yPoints_.set (x);
}

void CurveType::
yPoints (::std::auto_ptr< yPoints_type > x)
{
  this->yPoints_.set (x);
}


// MuscleDefaultType
// 

const MuscleDefaultType::percentageChange_type& MuscleDefaultType::
percentageChange () const
{
  return this->percentageChange_.get ();
}

MuscleDefaultType::percentageChange_type& MuscleDefaultType::
percentageChange ()
{
  return this->percentageChange_.get ();
}

void MuscleDefaultType::
percentageChange (const percentageChange_type& x)
{
  this->percentageChange_.set (x);
}

const MuscleDefaultType::damping_type& MuscleDefaultType::
damping () const
{
  return this->damping_.get ();
}

MuscleDefaultType::damping_type& MuscleDefaultType::
damping ()
{
  return this->damping_.get ();
}

void MuscleDefaultType::
damping (const damping_type& x)
{
  this->damping_.set (x);
}

const MuscleDefaultType::Curve_sequence& MuscleDefaultType::
Curve () const
{
  return this->Curve_;
}

MuscleDefaultType::Curve_sequence& MuscleDefaultType::
Curve ()
{
  return this->Curve_;
}

void MuscleDefaultType::
Curve (const Curve_sequence& s)
{
  this->Curve_ = s;
}


// NMSmodelType
// 

const NMSmodelType::muscleDefault_type& NMSmodelType::
muscleDefault () const
{
  return this->muscleDefault_.get ();
}

NMSmodelType::muscleDefault_type& NMSmodelType::
muscleDefault ()
{
  return this->muscleDefault_.get ();
}

void NMSmodelType::
muscleDefault (const muscleDefault_type& x)
{
  this->muscleDefault_.set (x);
}

void NMSmodelType::
muscleDefault (::std::auto_ptr< muscleDefault_type > x)
{
  this->muscleDefault_.set (x);
}

const NMSmodelType::muscles_type& NMSmodelType::
muscles () const
{
  return this->muscles_.get ();
}

NMSmodelType::muscles_type& NMSmodelType::
muscles ()
{
  return this->muscles_.get ();
}

void NMSmodelType::
muscles (const muscles_type& x)
{
  this->muscles_.set (x);
}

void NMSmodelType::
muscles (::std::auto_ptr< muscles_type > x)
{
  this->muscles_.set (x);
}

const NMSmodelType::DoFs_type& NMSmodelType::
DoFs () const
{
  return this->DoFs_.get ();
}

NMSmodelType::DoFs_type& NMSmodelType::
DoFs ()
{
  return this->DoFs_.get ();
}

void NMSmodelType::
DoFs (const DoFs_type& x)
{
  this->DoFs_.set (x);
}

void NMSmodelType::
DoFs (::std::auto_ptr< DoFs_type > x)
{
  this->DoFs_.set (x);
}

const NMSmodelType::Channels_type& NMSmodelType::
Channels () const
{
  return this->Channels_.get ();
}

NMSmodelType::Channels_type& NMSmodelType::
Channels ()
{
  return this->Channels_.get ();
}

void NMSmodelType::
Channels (const Channels_type& x)
{
  this->Channels_.set (x);
}

void NMSmodelType::
Channels (::std::auto_ptr< Channels_type > x)
{
  this->Channels_.set (x);
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// MuscleType
//

MuscleType::
MuscleType (const name_type& name,
            const C1_type& C1,
            const C2_type& C2,
            const shapeFactor_type& shapeFactor,
            const optimalFiberLength_type& optimalFiberLength,
            const pennationAngle_type& pennationAngle,
            const tendonSlackLength_type& tendonSlackLength,
            const maxIsometricForce_type& maxIsometricForce,
            const strengthCoefficient_type& strengthCoefficient)
: ::xml_schema::type (),
  name_ (name, this),
  C1_ (C1, this),
  C2_ (C2, this),
  shapeFactor_ (shapeFactor, this),
  optimalFiberLength_ (optimalFiberLength, this),
  pennationAngle_ (pennationAngle, this),
  tendonSlackLength_ (tendonSlackLength, this),
  maxIsometricForce_ (maxIsometricForce, this),
  strengthCoefficient_ (strengthCoefficient, this)
{
}

MuscleType::
MuscleType (const MuscleType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  name_ (x.name_, f, this),
  C1_ (x.C1_, f, this),
  C2_ (x.C2_, f, this),
  shapeFactor_ (x.shapeFactor_, f, this),
  optimalFiberLength_ (x.optimalFiberLength_, f, this),
  pennationAngle_ (x.pennationAngle_, f, this),
  tendonSlackLength_ (x.tendonSlackLength_, f, this),
  maxIsometricForce_ (x.maxIsometricForce_, f, this),
  strengthCoefficient_ (x.strengthCoefficient_, f, this)
{
}

MuscleType::
MuscleType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  name_ (this),
  C1_ (this),
  C2_ (this),
  shapeFactor_ (this),
  optimalFiberLength_ (this),
  pennationAngle_ (this),
  tendonSlackLength_ (this),
  maxIsometricForce_ (this),
  strengthCoefficient_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void MuscleType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // name
    //
    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< name_type > r (
        name_traits::create (i, f, this));

      if (!name_.present ())
      {
        this->name_.set (r);
        continue;
      }
    }

    // C1
    //
    if (n.name () == "C1" && n.namespace_ ().empty ())
    {
      if (!C1_.present ())
      {
        this->C1_.set (C1_traits::create (i, f, this));
        continue;
      }
    }

    // C2
    //
    if (n.name () == "C2" && n.namespace_ ().empty ())
    {
      if (!C2_.present ())
      {
        this->C2_.set (C2_traits::create (i, f, this));
        continue;
      }
    }

    // shapeFactor
    //
    if (n.name () == "shapeFactor" && n.namespace_ ().empty ())
    {
      if (!shapeFactor_.present ())
      {
        this->shapeFactor_.set (shapeFactor_traits::create (i, f, this));
        continue;
      }
    }

    // optimalFiberLength
    //
    if (n.name () == "optimalFiberLength" && n.namespace_ ().empty ())
    {
      if (!optimalFiberLength_.present ())
      {
        this->optimalFiberLength_.set (optimalFiberLength_traits::create (i, f, this));
        continue;
      }
    }

    // pennationAngle
    //
    if (n.name () == "pennationAngle" && n.namespace_ ().empty ())
    {
      if (!pennationAngle_.present ())
      {
        this->pennationAngle_.set (pennationAngle_traits::create (i, f, this));
        continue;
      }
    }

    // tendonSlackLength
    //
    if (n.name () == "tendonSlackLength" && n.namespace_ ().empty ())
    {
      if (!tendonSlackLength_.present ())
      {
        this->tendonSlackLength_.set (tendonSlackLength_traits::create (i, f, this));
        continue;
      }
    }

    // maxIsometricForce
    //
    if (n.name () == "maxIsometricForce" && n.namespace_ ().empty ())
    {
      if (!maxIsometricForce_.present ())
      {
        this->maxIsometricForce_.set (maxIsometricForce_traits::create (i, f, this));
        continue;
      }
    }

    // strengthCoefficient
    //
    if (n.name () == "strengthCoefficient" && n.namespace_ ().empty ())
    {
      if (!strengthCoefficient_.present ())
      {
        this->strengthCoefficient_.set (strengthCoefficient_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "name",
      "");
  }

  if (!C1_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "C1",
      "");
  }

  if (!C2_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "C2",
      "");
  }

  if (!shapeFactor_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "shapeFactor",
      "");
  }

  if (!optimalFiberLength_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "optimalFiberLength",
      "");
  }

  if (!pennationAngle_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "pennationAngle",
      "");
  }

  if (!tendonSlackLength_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "tendonSlackLength",
      "");
  }

  if (!maxIsometricForce_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "maxIsometricForce",
      "");
  }

  if (!strengthCoefficient_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "strengthCoefficient",
      "");
  }
}

MuscleType* MuscleType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class MuscleType (*this, f, c);
}

MuscleType& MuscleType::
operator= (const MuscleType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->name_ = x.name_;
    this->C1_ = x.C1_;
    this->C2_ = x.C2_;
    this->shapeFactor_ = x.shapeFactor_;
    this->optimalFiberLength_ = x.optimalFiberLength_;
    this->pennationAngle_ = x.pennationAngle_;
    this->tendonSlackLength_ = x.tendonSlackLength_;
    this->maxIsometricForce_ = x.maxIsometricForce_;
    this->strengthCoefficient_ = x.strengthCoefficient_;
  }

  return *this;
}

MuscleType::
~MuscleType ()
{
}

// MusclesType
//

MusclesType::
MusclesType ()
: ::xml_schema::type (),
  muscle_ (this)
{
}

MusclesType::
MusclesType (const MusclesType& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  muscle_ (x.muscle_, f, this)
{
}

MusclesType::
MusclesType (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  muscle_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void MusclesType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // muscle
    //
    if (n.name () == "muscle" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< muscle_type > r (
        muscle_traits::create (i, f, this));

      this->muscle_.push_back (r);
      continue;
    }

    break;
  }
}

MusclesType* MusclesType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class MusclesType (*this, f, c);
}

MusclesType& MusclesType::
operator= (const MusclesType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->muscle_ = x.muscle_;
  }

  return *this;
}

MusclesType::
~MusclesType ()
{
}

// MuscleSequenceType
//

MuscleSequenceType::
MuscleSequenceType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::simple_type (e, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::string, char > (e, f, this)
{
}

MuscleSequenceType::
MuscleSequenceType (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::simple_type (a, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::string, char > (a, f, this)
{
}

MuscleSequenceType::
MuscleSequenceType (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::simple_type (s, e, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::string, char > (s, e, f, this)
{
}

MuscleSequenceType* MuscleSequenceType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class MuscleSequenceType (*this, f, c);
}

MuscleSequenceType::
~MuscleSequenceType ()
{
}

// ChannelType
//

ChannelType::
ChannelType (const name_type& name,
             const muscleSequence_type& muscleSequence)
: ::xml_schema::type (),
  name_ (name, this),
  muscleSequence_ (muscleSequence, this)
{
}

ChannelType::
ChannelType (const ChannelType& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  name_ (x.name_, f, this),
  muscleSequence_ (x.muscleSequence_, f, this)
{
}

ChannelType::
ChannelType (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  name_ (this),
  muscleSequence_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void ChannelType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // name
    //
    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< name_type > r (
        name_traits::create (i, f, this));

      if (!name_.present ())
      {
        this->name_.set (r);
        continue;
      }
    }

    // muscleSequence
    //
    if (n.name () == "muscleSequence" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< muscleSequence_type > r (
        muscleSequence_traits::create (i, f, this));

      if (!muscleSequence_.present ())
      {
        this->muscleSequence_.set (r);
        continue;
      }
    }

    break;
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "name",
      "");
  }

  if (!muscleSequence_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "muscleSequence",
      "");
  }
}

ChannelType* ChannelType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ChannelType (*this, f, c);
}

ChannelType& ChannelType::
operator= (const ChannelType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->name_ = x.name_;
    this->muscleSequence_ = x.muscleSequence_;
  }

  return *this;
}

ChannelType::
~ChannelType ()
{
}

// ChannelsType
//

ChannelsType::
ChannelsType ()
: ::xml_schema::type (),
  Channel_ (this)
{
}

ChannelsType::
ChannelsType (const ChannelsType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Channel_ (x.Channel_, f, this)
{
}

ChannelsType::
ChannelsType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Channel_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void ChannelsType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Channel
    //
    if (n.name () == "Channel" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Channel_type > r (
        Channel_traits::create (i, f, this));

      this->Channel_.push_back (r);
      continue;
    }

    break;
  }
}

ChannelsType* ChannelsType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ChannelsType (*this, f, c);
}

ChannelsType& ChannelsType::
operator= (const ChannelsType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Channel_ = x.Channel_;
  }

  return *this;
}

ChannelsType::
~ChannelsType ()
{
}

// DoFType
//

DoFType::
DoFType (const name_type& name,
         const muscleSequence_type& muscleSequence)
: ::xml_schema::type (),
  name_ (name, this),
  muscleSequence_ (muscleSequence, this)
{
}

DoFType::
DoFType (const DoFType& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  name_ (x.name_, f, this),
  muscleSequence_ (x.muscleSequence_, f, this)
{
}

DoFType::
DoFType (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  name_ (this),
  muscleSequence_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void DoFType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // name
    //
    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< name_type > r (
        name_traits::create (i, f, this));

      if (!name_.present ())
      {
        this->name_.set (r);
        continue;
      }
    }

    // muscleSequence
    //
    if (n.name () == "muscleSequence" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< muscleSequence_type > r (
        muscleSequence_traits::create (i, f, this));

      if (!muscleSequence_.present ())
      {
        this->muscleSequence_.set (r);
        continue;
      }
    }

    break;
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "name",
      "");
  }

  if (!muscleSequence_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "muscleSequence",
      "");
  }
}

DoFType* DoFType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class DoFType (*this, f, c);
}

DoFType& DoFType::
operator= (const DoFType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->name_ = x.name_;
    this->muscleSequence_ = x.muscleSequence_;
  }

  return *this;
}

DoFType::
~DoFType ()
{
}

// DoFsType
//

DoFsType::
DoFsType ()
: ::xml_schema::type (),
  DoF_ (this)
{
}

DoFsType::
DoFsType (const DoFsType& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  DoF_ (x.DoF_, f, this)
{
}

DoFsType::
DoFsType (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  DoF_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void DoFsType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // DoF
    //
    if (n.name () == "DoF" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< DoF_type > r (
        DoF_traits::create (i, f, this));

      this->DoF_.push_back (r);
      continue;
    }

    break;
  }
}

DoFsType* DoFsType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class DoFsType (*this, f, c);
}

DoFsType& DoFsType::
operator= (const DoFsType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->DoF_ = x.DoF_;
  }

  return *this;
}

DoFsType::
~DoFsType ()
{
}

// PointsSequenceType
//

PointsSequenceType::
PointsSequenceType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::simple_type (e, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > (e, f, this)
{
}

PointsSequenceType::
PointsSequenceType (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::simple_type (a, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > (a, f, this)
{
}

PointsSequenceType::
PointsSequenceType (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::simple_type (s, e, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > (s, e, f, this)
{
}

PointsSequenceType* PointsSequenceType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class PointsSequenceType (*this, f, c);
}

PointsSequenceType::
~PointsSequenceType ()
{
}

// CurveType
//

CurveType::
CurveType (const name_type& name,
           const xPoints_type& xPoints,
           const yPoints_type& yPoints)
: ::xml_schema::type (),
  name_ (name, this),
  xPoints_ (xPoints, this),
  yPoints_ (yPoints, this)
{
}

CurveType::
CurveType (const CurveType& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  name_ (x.name_, f, this),
  xPoints_ (x.xPoints_, f, this),
  yPoints_ (x.yPoints_, f, this)
{
}

CurveType::
CurveType (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  name_ (this),
  xPoints_ (this),
  yPoints_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void CurveType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // name
    //
    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< name_type > r (
        name_traits::create (i, f, this));

      if (!name_.present ())
      {
        this->name_.set (r);
        continue;
      }
    }

    // xPoints
    //
    if (n.name () == "xPoints" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< xPoints_type > r (
        xPoints_traits::create (i, f, this));

      if (!xPoints_.present ())
      {
        this->xPoints_.set (r);
        continue;
      }
    }

    // yPoints
    //
    if (n.name () == "yPoints" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< yPoints_type > r (
        yPoints_traits::create (i, f, this));

      if (!yPoints_.present ())
      {
        this->yPoints_.set (r);
        continue;
      }
    }

    break;
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "name",
      "");
  }

  if (!xPoints_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "xPoints",
      "");
  }

  if (!yPoints_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "yPoints",
      "");
  }
}

CurveType* CurveType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class CurveType (*this, f, c);
}

CurveType& CurveType::
operator= (const CurveType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->name_ = x.name_;
    this->xPoints_ = x.xPoints_;
    this->yPoints_ = x.yPoints_;
  }

  return *this;
}

CurveType::
~CurveType ()
{
}

// MuscleDefaultType
//

MuscleDefaultType::
MuscleDefaultType (const percentageChange_type& percentageChange,
                   const damping_type& damping)
: ::xml_schema::type (),
  percentageChange_ (percentageChange, this),
  damping_ (damping, this),
  Curve_ (this)
{
}

MuscleDefaultType::
MuscleDefaultType (const MuscleDefaultType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  percentageChange_ (x.percentageChange_, f, this),
  damping_ (x.damping_, f, this),
  Curve_ (x.Curve_, f, this)
{
}

MuscleDefaultType::
MuscleDefaultType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  percentageChange_ (this),
  damping_ (this),
  Curve_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void MuscleDefaultType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // percentageChange
    //
    if (n.name () == "percentageChange" && n.namespace_ ().empty ())
    {
      if (!percentageChange_.present ())
      {
        this->percentageChange_.set (percentageChange_traits::create (i, f, this));
        continue;
      }
    }

    // damping
    //
    if (n.name () == "damping" && n.namespace_ ().empty ())
    {
      if (!damping_.present ())
      {
        this->damping_.set (damping_traits::create (i, f, this));
        continue;
      }
    }

    // Curve
    //
    if (n.name () == "Curve" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Curve_type > r (
        Curve_traits::create (i, f, this));

      this->Curve_.push_back (r);
      continue;
    }

    break;
  }

  if (!percentageChange_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "percentageChange",
      "");
  }

  if (!damping_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "damping",
      "");
  }
}

MuscleDefaultType* MuscleDefaultType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class MuscleDefaultType (*this, f, c);
}

MuscleDefaultType& MuscleDefaultType::
operator= (const MuscleDefaultType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->percentageChange_ = x.percentageChange_;
    this->damping_ = x.damping_;
    this->Curve_ = x.Curve_;
  }

  return *this;
}

MuscleDefaultType::
~MuscleDefaultType ()
{
}

// NMSmodelType
//

NMSmodelType::
NMSmodelType (const muscleDefault_type& muscleDefault,
              const muscles_type& muscles,
              const DoFs_type& DoFs,
              const Channels_type& Channels)
: ::xml_schema::type (),
  muscleDefault_ (muscleDefault, this),
  muscles_ (muscles, this),
  DoFs_ (DoFs, this),
  Channels_ (Channels, this)
{
}

NMSmodelType::
NMSmodelType (::std::auto_ptr< muscleDefault_type > muscleDefault,
              ::std::auto_ptr< muscles_type > muscles,
              ::std::auto_ptr< DoFs_type > DoFs,
              ::std::auto_ptr< Channels_type > Channels)
: ::xml_schema::type (),
  muscleDefault_ (muscleDefault, this),
  muscles_ (muscles, this),
  DoFs_ (DoFs, this),
  Channels_ (Channels, this)
{
}

NMSmodelType::
NMSmodelType (const NMSmodelType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  muscleDefault_ (x.muscleDefault_, f, this),
  muscles_ (x.muscles_, f, this),
  DoFs_ (x.DoFs_, f, this),
  Channels_ (x.Channels_, f, this)
{
}

NMSmodelType::
NMSmodelType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  muscleDefault_ (this),
  muscles_ (this),
  DoFs_ (this),
  Channels_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void NMSmodelType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // muscleDefault
    //
    if (n.name () == "muscleDefault" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< muscleDefault_type > r (
        muscleDefault_traits::create (i, f, this));

      if (!muscleDefault_.present ())
      {
        this->muscleDefault_.set (r);
        continue;
      }
    }

    // muscles
    //
    if (n.name () == "muscles" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< muscles_type > r (
        muscles_traits::create (i, f, this));

      if (!muscles_.present ())
      {
        this->muscles_.set (r);
        continue;
      }
    }

    // DoFs
    //
    if (n.name () == "DoFs" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< DoFs_type > r (
        DoFs_traits::create (i, f, this));

      if (!DoFs_.present ())
      {
        this->DoFs_.set (r);
        continue;
      }
    }

    // Channels
    //
    if (n.name () == "Channels" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Channels_type > r (
        Channels_traits::create (i, f, this));

      if (!Channels_.present ())
      {
        this->Channels_.set (r);
        continue;
      }
    }

    break;
  }

  if (!muscleDefault_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "muscleDefault",
      "");
  }

  if (!muscles_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "muscles",
      "");
  }

  if (!DoFs_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "DoFs",
      "");
  }

  if (!Channels_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Channels",
      "");
  }
}

NMSmodelType* NMSmodelType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class NMSmodelType (*this, f, c);
}

NMSmodelType& NMSmodelType::
operator= (const NMSmodelType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->muscleDefault_ = x.muscleDefault_;
    this->muscles_ = x.muscles_;
    this->DoFs_ = x.DoFs_;
    this->Channels_ = x.Channels_;
  }

  return *this;
}

NMSmodelType::
~NMSmodelType ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::auto_ptr< ::NMSmodelType >
subject (const ::std::string& u,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::NMSmodelType > (
    ::subject (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::NMSmodelType >
subject (const ::std::string& u,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::NMSmodelType > (
    ::subject (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::NMSmodelType >
subject (const ::std::string& u,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::NMSmodelType > (
    ::subject (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::NMSmodelType >
subject (::std::istream& is,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::subject (isrc, f, p);
}

::std::auto_ptr< ::NMSmodelType >
subject (::std::istream& is,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::subject (isrc, h, f, p);
}

::std::auto_ptr< ::NMSmodelType >
subject (::std::istream& is,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::subject (isrc, h, f, p);
}

::std::auto_ptr< ::NMSmodelType >
subject (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::subject (isrc, f, p);
}

::std::auto_ptr< ::NMSmodelType >
subject (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::subject (isrc, h, f, p);
}

::std::auto_ptr< ::NMSmodelType >
subject (::std::istream& is,
         const ::std::string& sid,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::subject (isrc, h, f, p);
}

::std::auto_ptr< ::NMSmodelType >
subject (::xercesc::InputSource& i,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::NMSmodelType > (
    ::subject (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::NMSmodelType >
subject (::xercesc::InputSource& i,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::NMSmodelType > (
    ::subject (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::NMSmodelType >
subject (::xercesc::InputSource& i,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::NMSmodelType > (
    ::subject (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::NMSmodelType >
subject (const ::xercesc::DOMDocument& doc,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::NMSmodelType > (
      ::subject (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "subject" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::NMSmodelType > r (
      ::xsd::cxx::tree::traits< ::NMSmodelType, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "subject",
    "");
}

::std::auto_ptr< ::NMSmodelType >
subject (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
         ::xml_schema::flags f,
         const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "subject" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::NMSmodelType > r (
      ::xsd::cxx::tree::traits< ::NMSmodelType, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "subject",
    "");
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

void
operator<< (::xercesc::DOMElement& e, const MuscleType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // name
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "name",
        e));

    s << i.name ();
  }

  // C1
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "C1",
        e));

    s << ::xml_schema::as_double(i.C1 ());
  }

  // C2
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "C2",
        e));

    s << ::xml_schema::as_double(i.C2 ());
  }

  // shapeFactor
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "shapeFactor",
        e));

    s << ::xml_schema::as_double(i.shapeFactor ());
  }

  // optimalFiberLength
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "optimalFiberLength",
        e));

    s << ::xml_schema::as_double(i.optimalFiberLength ());
  }

  // pennationAngle
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "pennationAngle",
        e));

    s << ::xml_schema::as_double(i.pennationAngle ());
  }

  // tendonSlackLength
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "tendonSlackLength",
        e));

    s << ::xml_schema::as_double(i.tendonSlackLength ());
  }

  // maxIsometricForce
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "maxIsometricForce",
        e));

    s << ::xml_schema::as_double(i.maxIsometricForce ());
  }

  // strengthCoefficient
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "strengthCoefficient",
        e));

    s << ::xml_schema::as_double(i.strengthCoefficient ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const MusclesType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // muscle
  //
  for (MusclesType::muscle_const_iterator
       b (i.muscle ().begin ()), n (i.muscle ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "muscle",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const MuscleSequenceType& i)
{
  e << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::string, char >& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const MuscleSequenceType& i)
{
  a << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::string, char >& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const MuscleSequenceType& i)
{
  l << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::string, char >& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const ChannelType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // name
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "name",
        e));

    s << i.name ();
  }

  // muscleSequence
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "muscleSequence",
        e));

    s << i.muscleSequence ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const ChannelsType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Channel
  //
  for (ChannelsType::Channel_const_iterator
       b (i.Channel ().begin ()), n (i.Channel ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Channel",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const DoFType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // name
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "name",
        e));

    s << i.name ();
  }

  // muscleSequence
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "muscleSequence",
        e));

    s << i.muscleSequence ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const DoFsType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // DoF
  //
  for (DoFsType::DoF_const_iterator
       b (i.DoF ().begin ()), n (i.DoF ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "DoF",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const PointsSequenceType& i)
{
  e << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const PointsSequenceType& i)
{
  a << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const PointsSequenceType& i)
{
  l << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const CurveType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // name
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "name",
        e));

    s << i.name ();
  }

  // xPoints
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "xPoints",
        e));

    s << i.xPoints ();
  }

  // yPoints
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "yPoints",
        e));

    s << i.yPoints ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const MuscleDefaultType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // percentageChange
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "percentageChange",
        e));

    s << ::xml_schema::as_double(i.percentageChange ());
  }

  // damping
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "damping",
        e));

    s << ::xml_schema::as_double(i.damping ());
  }

  // Curve
  //
  for (MuscleDefaultType::Curve_const_iterator
       b (i.Curve ().begin ()), n (i.Curve ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Curve",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const NMSmodelType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // muscleDefault
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "muscleDefault",
        e));

    s << i.muscleDefault ();
  }

  // muscles
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "muscles",
        e));

    s << i.muscles ();
  }

  // DoFs
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "DoFs",
        e));

    s << i.DoFs ();
  }

  // Channels
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Channels",
        e));

    s << i.Channels ();
  }
}

void
subject (::std::ostream& o,
         const ::NMSmodelType& s,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::subject (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
subject (::std::ostream& o,
         const ::NMSmodelType& s,
         ::xml_schema::error_handler& h,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::subject (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
subject (::std::ostream& o,
         const ::NMSmodelType& s,
         ::xercesc::DOMErrorHandler& h,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::subject (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
subject (::xercesc::XMLFormatTarget& t,
         const ::NMSmodelType& s,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::subject (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
subject (::xercesc::XMLFormatTarget& t,
         const ::NMSmodelType& s,
         ::xml_schema::error_handler& h,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::subject (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
subject (::xercesc::XMLFormatTarget& t,
         const ::NMSmodelType& s,
         ::xercesc::DOMErrorHandler& h,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::subject (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
subject (::xercesc::DOMDocument& d,
         const ::NMSmodelType& s,
         ::xml_schema::flags)
{
  ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "subject" &&
      n.namespace_ () == "")
  {
    e << s;
  }
  else
  {
    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "subject",
      "");
  }
}

::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
subject (const ::NMSmodelType& s,
         const ::xml_schema::namespace_infomap& m,
         ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::serialize< char > (
      "subject",
      "",
      m, f));

  ::subject (*d, s, f);
  return d;
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

