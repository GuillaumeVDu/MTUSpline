// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef EXECUTION_HXX
#define EXECUTION_HXX

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< char, type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;
  typedef ::xsd::cxx::tree::name< char, token > name;
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;
  typedef ::xsd::cxx::tree::language< char, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, ncname > id;
  typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< char, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< char, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;

  typedef ::xsd::cxx::tree::content_order content_order;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info< char > namespace_info;
  typedef ::xsd::cxx::xml::dom::namespace_infomap< char > namespace_infomap;
  typedef ::xsd::cxx::tree::list_stream< char > list_stream;
  typedef ::xsd::cxx::tree::as_double< double_ > as_double;
  typedef ::xsd::cxx::tree::as_decimal< decimal > as_decimal;
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< char > error;
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > exception;
  typedef ::xsd::cxx::tree::bounds< char > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< char > parsing;
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;
  typedef ::xsd::cxx::tree::serialization< char > serialization;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::auto_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
class TendonElementType;
class TendonType;
class ActivationElementType;
class ActivationType;
class HybridAlgorithmSimulatedAnnealingType;
class HybridAlgorithmType;
class OpenLoopType;
class MuscleListType;
class HybridType;
class DevicePluginType;
class RealTimeType;
class OnlineType;
class OfflineType;
class CurvechoiceType;
class TypeType;
class NMSModelType;
class ElaboratedDoFsType;
class ExecutionElementType;
class FileType;
class LoggingType;
class ExecutionType;

#include <memory>    // ::std::auto_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

class TendonElementType: public ::xml_schema::type
{
  public:
  // Constructors.
  //
  TendonElementType ();

  TendonElementType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  TendonElementType (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  TendonElementType (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  TendonElementType (const TendonElementType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  virtual TendonElementType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~TendonElementType ();
};

class TendonType: public ::xml_schema::type
{
  public:
  // stiff
  //
  typedef ::TendonElementType stiff_type;
  typedef ::xsd::cxx::tree::optional< stiff_type > stiff_optional;
  typedef ::xsd::cxx::tree::traits< stiff_type, char > stiff_traits;

  const stiff_optional&
  stiff () const;

  stiff_optional&
  stiff ();

  void
  stiff (const stiff_type& x);

  void
  stiff (const stiff_optional& x);

  void
  stiff (::std::auto_ptr< stiff_type > p);

  // elastic
  //
  typedef ::TendonElementType elastic_type;
  typedef ::xsd::cxx::tree::optional< elastic_type > elastic_optional;
  typedef ::xsd::cxx::tree::traits< elastic_type, char > elastic_traits;

  const elastic_optional&
  elastic () const;

  elastic_optional&
  elastic ();

  void
  elastic (const elastic_type& x);

  void
  elastic (const elastic_optional& x);

  void
  elastic (::std::auto_ptr< elastic_type > p);

  // elasticBiSec
  //
  typedef ::TendonElementType elasticBiSec_type;
  typedef ::xsd::cxx::tree::optional< elasticBiSec_type > elasticBiSec_optional;
  typedef ::xsd::cxx::tree::traits< elasticBiSec_type, char > elasticBiSec_traits;

  const elasticBiSec_optional&
  elasticBiSec () const;

  elasticBiSec_optional&
  elasticBiSec ();

  void
  elasticBiSec (const elasticBiSec_type& x);

  void
  elasticBiSec (const elasticBiSec_optional& x);

  void
  elasticBiSec (::std::auto_ptr< elasticBiSec_type > p);

  // Constructors.
  //
  TendonType ();

  TendonType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  TendonType (const TendonType& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual TendonType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  TendonType&
  operator= (const TendonType& x);

  virtual 
  ~TendonType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  stiff_optional stiff_;
  elastic_optional elastic_;
  elasticBiSec_optional elasticBiSec_;
};

class ActivationElementType: public ::xml_schema::type
{
  public:
  // Constructors.
  //
  ActivationElementType ();

  ActivationElementType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  ActivationElementType (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  ActivationElementType (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  ActivationElementType (const ActivationElementType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  virtual ActivationElementType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~ActivationElementType ();
};

class ActivationType: public ::xml_schema::type
{
  public:
  // exponential
  //
  typedef ::ActivationElementType exponential_type;
  typedef ::xsd::cxx::tree::optional< exponential_type > exponential_optional;
  typedef ::xsd::cxx::tree::traits< exponential_type, char > exponential_traits;

  const exponential_optional&
  exponential () const;

  exponential_optional&
  exponential ();

  void
  exponential (const exponential_type& x);

  void
  exponential (const exponential_optional& x);

  void
  exponential (::std::auto_ptr< exponential_type > p);

  // piecewise
  //
  typedef ::ActivationElementType piecewise_type;
  typedef ::xsd::cxx::tree::optional< piecewise_type > piecewise_optional;
  typedef ::xsd::cxx::tree::traits< piecewise_type, char > piecewise_traits;

  const piecewise_optional&
  piecewise () const;

  piecewise_optional&
  piecewise ();

  void
  piecewise (const piecewise_type& x);

  void
  piecewise (const piecewise_optional& x);

  void
  piecewise (::std::auto_ptr< piecewise_type > p);

  // Constructors.
  //
  ActivationType ();

  ActivationType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  ActivationType (const ActivationType& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  virtual ActivationType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ActivationType&
  operator= (const ActivationType& x);

  virtual 
  ~ActivationType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  exponential_optional exponential_;
  piecewise_optional piecewise_;
};

class HybridAlgorithmSimulatedAnnealingType: public ::xml_schema::type
{
  public:
  // noEpsilon
  //
  typedef ::xml_schema::int_ noEpsilon_type;
  typedef ::xsd::cxx::tree::traits< noEpsilon_type, char > noEpsilon_traits;

  const noEpsilon_type&
  noEpsilon () const;

  noEpsilon_type&
  noEpsilon ();

  void
  noEpsilon (const noEpsilon_type& x);

  // rt
  //
  typedef ::xml_schema::double_ rt_type;
  typedef ::xsd::cxx::tree::traits< rt_type, char, ::xsd::cxx::tree::schema_type::double_ > rt_traits;

  const rt_type&
  rt () const;

  rt_type&
  rt ();

  void
  rt (const rt_type& x);

  // T
  //
  typedef ::xml_schema::double_ T_type;
  typedef ::xsd::cxx::tree::traits< T_type, char, ::xsd::cxx::tree::schema_type::double_ > T_traits;

  const T_type&
  T () const;

  T_type&
  T ();

  void
  T (const T_type& x);

  // NS
  //
  typedef ::xml_schema::int_ NS_type;
  typedef ::xsd::cxx::tree::traits< NS_type, char > NS_traits;

  const NS_type&
  NS () const;

  NS_type&
  NS ();

  void
  NS (const NS_type& x);

  // NT
  //
  typedef ::xml_schema::int_ NT_type;
  typedef ::xsd::cxx::tree::traits< NT_type, char > NT_traits;

  const NT_type&
  NT () const;

  NT_type&
  NT ();

  void
  NT (const NT_type& x);

  // epsilon
  //
  typedef ::xml_schema::double_ epsilon_type;
  typedef ::xsd::cxx::tree::traits< epsilon_type, char, ::xsd::cxx::tree::schema_type::double_ > epsilon_traits;

  const epsilon_type&
  epsilon () const;

  epsilon_type&
  epsilon ();

  void
  epsilon (const epsilon_type& x);

  // maxNoEval
  //
  typedef ::xml_schema::int_ maxNoEval_type;
  typedef ::xsd::cxx::tree::traits< maxNoEval_type, char > maxNoEval_traits;

  const maxNoEval_type&
  maxNoEval () const;

  maxNoEval_type&
  maxNoEval ();

  void
  maxNoEval (const maxNoEval_type& x);

  // Constructors.
  //
  HybridAlgorithmSimulatedAnnealingType (const noEpsilon_type&,
                                         const rt_type&,
                                         const T_type&,
                                         const NS_type&,
                                         const NT_type&,
                                         const epsilon_type&,
                                         const maxNoEval_type&);

  HybridAlgorithmSimulatedAnnealingType (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

  HybridAlgorithmSimulatedAnnealingType (const HybridAlgorithmSimulatedAnnealingType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

  virtual HybridAlgorithmSimulatedAnnealingType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  HybridAlgorithmSimulatedAnnealingType&
  operator= (const HybridAlgorithmSimulatedAnnealingType& x);

  virtual 
  ~HybridAlgorithmSimulatedAnnealingType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< noEpsilon_type > noEpsilon_;
  ::xsd::cxx::tree::one< rt_type > rt_;
  ::xsd::cxx::tree::one< T_type > T_;
  ::xsd::cxx::tree::one< NS_type > NS_;
  ::xsd::cxx::tree::one< NT_type > NT_;
  ::xsd::cxx::tree::one< epsilon_type > epsilon_;
  ::xsd::cxx::tree::one< maxNoEval_type > maxNoEval_;
};

class HybridAlgorithmType: public ::xml_schema::type
{
  public:
  // hybridSimulatedAnnealing
  //
  typedef ::HybridAlgorithmSimulatedAnnealingType hybridSimulatedAnnealing_type;
  typedef ::xsd::cxx::tree::traits< hybridSimulatedAnnealing_type, char > hybridSimulatedAnnealing_traits;

  const hybridSimulatedAnnealing_type&
  hybridSimulatedAnnealing () const;

  hybridSimulatedAnnealing_type&
  hybridSimulatedAnnealing ();

  void
  hybridSimulatedAnnealing (const hybridSimulatedAnnealing_type& x);

  void
  hybridSimulatedAnnealing (::std::auto_ptr< hybridSimulatedAnnealing_type > p);

  // Constructors.
  //
  HybridAlgorithmType (const hybridSimulatedAnnealing_type&);

  HybridAlgorithmType (::std::auto_ptr< hybridSimulatedAnnealing_type >);

  HybridAlgorithmType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  HybridAlgorithmType (const HybridAlgorithmType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  virtual HybridAlgorithmType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  HybridAlgorithmType&
  operator= (const HybridAlgorithmType& x);

  virtual 
  ~HybridAlgorithmType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< hybridSimulatedAnnealing_type > hybridSimulatedAnnealing_;
};

class OpenLoopType: public ::xml_schema::type
{
  public:
  // Constructors.
  //
  OpenLoopType ();

  OpenLoopType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  OpenLoopType (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  OpenLoopType (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  OpenLoopType (const OpenLoopType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual OpenLoopType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~OpenLoopType ();
};

class MuscleListType: public ::xml_schema::simple_type,
  public ::xsd::cxx::tree::list< ::xml_schema::string, char >
{
  public:
  MuscleListType ();

  MuscleListType (size_type n, const ::xml_schema::string& x);

  template < typename I >
  MuscleListType (const I& begin, const I& end)
  : ::xsd::cxx::tree::list< ::xml_schema::string, char > (begin, end, this)
  {
  }

  MuscleListType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  MuscleListType (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  MuscleListType (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  MuscleListType (const MuscleListType& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  virtual MuscleListType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~MuscleListType ();
};

class HybridType: public ::xml_schema::type
{
  public:
  // alpha
  //
  typedef ::xml_schema::double_ alpha_type;
  typedef ::xsd::cxx::tree::traits< alpha_type, char, ::xsd::cxx::tree::schema_type::double_ > alpha_traits;

  const alpha_type&
  alpha () const;

  alpha_type&
  alpha ();

  void
  alpha (const alpha_type& x);

  // beta
  //
  typedef ::xml_schema::double_ beta_type;
  typedef ::xsd::cxx::tree::traits< beta_type, char, ::xsd::cxx::tree::schema_type::double_ > beta_traits;

  const beta_type&
  beta () const;

  beta_type&
  beta ();

  void
  beta (const beta_type& x);

  // gamma
  //
  typedef ::xml_schema::double_ gamma_type;
  typedef ::xsd::cxx::tree::traits< gamma_type, char, ::xsd::cxx::tree::schema_type::double_ > gamma_traits;

  const gamma_type&
  gamma () const;

  gamma_type&
  gamma ();

  void
  gamma (const gamma_type& x);

  // trackedMuscles
  //
  typedef ::MuscleListType trackedMuscles_type;
  typedef ::xsd::cxx::tree::traits< trackedMuscles_type, char > trackedMuscles_traits;

  const trackedMuscles_type&
  trackedMuscles () const;

  trackedMuscles_type&
  trackedMuscles ();

  void
  trackedMuscles (const trackedMuscles_type& x);

  void
  trackedMuscles (::std::auto_ptr< trackedMuscles_type > p);

  // predictedMuscles
  //
  typedef ::MuscleListType predictedMuscles_type;
  typedef ::xsd::cxx::tree::traits< predictedMuscles_type, char > predictedMuscles_traits;

  const predictedMuscles_type&
  predictedMuscles () const;

  predictedMuscles_type&
  predictedMuscles ();

  void
  predictedMuscles (const predictedMuscles_type& x);

  void
  predictedMuscles (::std::auto_ptr< predictedMuscles_type > p);

  // algorithm
  //
  typedef ::HybridAlgorithmType algorithm_type;
  typedef ::xsd::cxx::tree::traits< algorithm_type, char > algorithm_traits;

  const algorithm_type&
  algorithm () const;

  algorithm_type&
  algorithm ();

  void
  algorithm (const algorithm_type& x);

  void
  algorithm (::std::auto_ptr< algorithm_type > p);

  // Constructors.
  //
  HybridType (const alpha_type&,
              const beta_type&,
              const gamma_type&,
              const trackedMuscles_type&,
              const predictedMuscles_type&,
              const algorithm_type&);

  HybridType (const alpha_type&,
              const beta_type&,
              const gamma_type&,
              const trackedMuscles_type&,
              const predictedMuscles_type&,
              ::std::auto_ptr< algorithm_type >);

  HybridType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  HybridType (const HybridType& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual HybridType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  HybridType&
  operator= (const HybridType& x);

  virtual 
  ~HybridType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< alpha_type > alpha_;
  ::xsd::cxx::tree::one< beta_type > beta_;
  ::xsd::cxx::tree::one< gamma_type > gamma_;
  ::xsd::cxx::tree::one< trackedMuscles_type > trackedMuscles_;
  ::xsd::cxx::tree::one< predictedMuscles_type > predictedMuscles_;
  ::xsd::cxx::tree::one< algorithm_type > algorithm_;
};

class DevicePluginType: public ::xml_schema::type
{
  public:
  // EMGDevice
  //
  typedef ::xml_schema::string EMGDevice_type;
  typedef ::xsd::cxx::tree::optional< EMGDevice_type > EMGDevice_optional;
  typedef ::xsd::cxx::tree::traits< EMGDevice_type, char > EMGDevice_traits;

  const EMGDevice_optional&
  EMGDevice () const;

  EMGDevice_optional&
  EMGDevice ();

  void
  EMGDevice (const EMGDevice_type& x);

  void
  EMGDevice (const EMGDevice_optional& x);

  void
  EMGDevice (::std::auto_ptr< EMGDevice_type > p);

  // EMGDeviceFile
  //
  typedef ::xml_schema::string EMGDeviceFile_type;
  typedef ::xsd::cxx::tree::optional< EMGDeviceFile_type > EMGDeviceFile_optional;
  typedef ::xsd::cxx::tree::traits< EMGDeviceFile_type, char > EMGDeviceFile_traits;

  const EMGDeviceFile_optional&
  EMGDeviceFile () const;

  EMGDeviceFile_optional&
  EMGDeviceFile ();

  void
  EMGDeviceFile (const EMGDeviceFile_type& x);

  void
  EMGDeviceFile (const EMGDeviceFile_optional& x);

  void
  EMGDeviceFile (::std::auto_ptr< EMGDeviceFile_type > p);

  // AngleDevice
  //
  typedef ::xml_schema::string AngleDevice_type;
  typedef ::xsd::cxx::tree::optional< AngleDevice_type > AngleDevice_optional;
  typedef ::xsd::cxx::tree::traits< AngleDevice_type, char > AngleDevice_traits;

  const AngleDevice_optional&
  AngleDevice () const;

  AngleDevice_optional&
  AngleDevice ();

  void
  AngleDevice (const AngleDevice_type& x);

  void
  AngleDevice (const AngleDevice_optional& x);

  void
  AngleDevice (::std::auto_ptr< AngleDevice_type > p);

  // AngleDeviceFile
  //
  typedef ::xml_schema::string AngleDeviceFile_type;
  typedef ::xsd::cxx::tree::optional< AngleDeviceFile_type > AngleDeviceFile_optional;
  typedef ::xsd::cxx::tree::traits< AngleDeviceFile_type, char > AngleDeviceFile_traits;

  const AngleDeviceFile_optional&
  AngleDeviceFile () const;

  AngleDeviceFile_optional&
  AngleDeviceFile ();

  void
  AngleDeviceFile (const AngleDeviceFile_type& x);

  void
  AngleDeviceFile (const AngleDeviceFile_optional& x);

  void
  AngleDeviceFile (::std::auto_ptr< AngleDeviceFile_type > p);

  // TorqueDevice
  //
  typedef ::xml_schema::string TorqueDevice_type;
  typedef ::xsd::cxx::tree::optional< TorqueDevice_type > TorqueDevice_optional;
  typedef ::xsd::cxx::tree::traits< TorqueDevice_type, char > TorqueDevice_traits;

  const TorqueDevice_optional&
  TorqueDevice () const;

  TorqueDevice_optional&
  TorqueDevice ();

  void
  TorqueDevice (const TorqueDevice_type& x);

  void
  TorqueDevice (const TorqueDevice_optional& x);

  void
  TorqueDevice (::std::auto_ptr< TorqueDevice_type > p);

  // TorqueDeviceFile
  //
  typedef ::xml_schema::string TorqueDeviceFile_type;
  typedef ::xsd::cxx::tree::optional< TorqueDeviceFile_type > TorqueDeviceFile_optional;
  typedef ::xsd::cxx::tree::traits< TorqueDeviceFile_type, char > TorqueDeviceFile_traits;

  const TorqueDeviceFile_optional&
  TorqueDeviceFile () const;

  TorqueDeviceFile_optional&
  TorqueDeviceFile ();

  void
  TorqueDeviceFile (const TorqueDeviceFile_type& x);

  void
  TorqueDeviceFile (const TorqueDeviceFile_optional& x);

  void
  TorqueDeviceFile (::std::auto_ptr< TorqueDeviceFile_type > p);

  // ComsumerDevice
  //
  typedef ::xml_schema::string ComsumerDevice_type;
  typedef ::xsd::cxx::tree::optional< ComsumerDevice_type > ComsumerDevice_optional;
  typedef ::xsd::cxx::tree::traits< ComsumerDevice_type, char > ComsumerDevice_traits;

  const ComsumerDevice_optional&
  ComsumerDevice () const;

  ComsumerDevice_optional&
  ComsumerDevice ();

  void
  ComsumerDevice (const ComsumerDevice_type& x);

  void
  ComsumerDevice (const ComsumerDevice_optional& x);

  void
  ComsumerDevice (::std::auto_ptr< ComsumerDevice_type > p);

  // ComsumerPort
  //
  typedef ::xml_schema::string ComsumerPort_type;
  typedef ::xsd::cxx::tree::optional< ComsumerPort_type > ComsumerPort_optional;
  typedef ::xsd::cxx::tree::traits< ComsumerPort_type, char > ComsumerPort_traits;

  const ComsumerPort_optional&
  ComsumerPort () const;

  ComsumerPort_optional&
  ComsumerPort ();

  void
  ComsumerPort (const ComsumerPort_type& x);

  void
  ComsumerPort (const ComsumerPort_optional& x);

  void
  ComsumerPort (::std::auto_ptr< ComsumerPort_type > p);

  // EMGAndAngleDevice
  //
  typedef ::xml_schema::string EMGAndAngleDevice_type;
  typedef ::xsd::cxx::tree::optional< EMGAndAngleDevice_type > EMGAndAngleDevice_optional;
  typedef ::xsd::cxx::tree::traits< EMGAndAngleDevice_type, char > EMGAndAngleDevice_traits;

  const EMGAndAngleDevice_optional&
  EMGAndAngleDevice () const;

  EMGAndAngleDevice_optional&
  EMGAndAngleDevice ();

  void
  EMGAndAngleDevice (const EMGAndAngleDevice_type& x);

  void
  EMGAndAngleDevice (const EMGAndAngleDevice_optional& x);

  void
  EMGAndAngleDevice (::std::auto_ptr< EMGAndAngleDevice_type > p);

  // OptimizationDevice
  //
  typedef ::xml_schema::string OptimizationDevice_type;
  typedef ::xsd::cxx::tree::optional< OptimizationDevice_type > OptimizationDevice_optional;
  typedef ::xsd::cxx::tree::traits< OptimizationDevice_type, char > OptimizationDevice_traits;

  const OptimizationDevice_optional&
  OptimizationDevice () const;

  OptimizationDevice_optional&
  OptimizationDevice ();

  void
  OptimizationDevice (const OptimizationDevice_type& x);

  void
  OptimizationDevice (const OptimizationDevice_optional& x);

  void
  OptimizationDevice (::std::auto_ptr< OptimizationDevice_type > p);

  // OptimizationFile
  //
  typedef ::xml_schema::string OptimizationFile_type;
  typedef ::xsd::cxx::tree::optional< OptimizationFile_type > OptimizationFile_optional;
  typedef ::xsd::cxx::tree::traits< OptimizationFile_type, char > OptimizationFile_traits;

  const OptimizationFile_optional&
  OptimizationFile () const;

  OptimizationFile_optional&
  OptimizationFile ();

  void
  OptimizationFile (const OptimizationFile_type& x);

  void
  OptimizationFile (const OptimizationFile_optional& x);

  void
  OptimizationFile (::std::auto_ptr< OptimizationFile_type > p);

  // AngleAndComsumerDevice
  //
  typedef ::xml_schema::string AngleAndComsumerDevice_type;
  typedef ::xsd::cxx::tree::optional< AngleAndComsumerDevice_type > AngleAndComsumerDevice_optional;
  typedef ::xsd::cxx::tree::traits< AngleAndComsumerDevice_type, char > AngleAndComsumerDevice_traits;

  const AngleAndComsumerDevice_optional&
  AngleAndComsumerDevice () const;

  AngleAndComsumerDevice_optional&
  AngleAndComsumerDevice ();

  void
  AngleAndComsumerDevice (const AngleAndComsumerDevice_type& x);

  void
  AngleAndComsumerDevice (const AngleAndComsumerDevice_optional& x);

  void
  AngleAndComsumerDevice (::std::auto_ptr< AngleAndComsumerDevice_type > p);

  // Constructors.
  //
  DevicePluginType ();

  DevicePluginType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  DevicePluginType (const DevicePluginType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  virtual DevicePluginType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  DevicePluginType&
  operator= (const DevicePluginType& x);

  virtual 
  ~DevicePluginType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  EMGDevice_optional EMGDevice_;
  EMGDeviceFile_optional EMGDeviceFile_;
  AngleDevice_optional AngleDevice_;
  AngleDeviceFile_optional AngleDeviceFile_;
  TorqueDevice_optional TorqueDevice_;
  TorqueDeviceFile_optional TorqueDeviceFile_;
  ComsumerDevice_optional ComsumerDevice_;
  ComsumerPort_optional ComsumerPort_;
  EMGAndAngleDevice_optional EMGAndAngleDevice_;
  OptimizationDevice_optional OptimizationDevice_;
  OptimizationFile_optional OptimizationFile_;
  AngleAndComsumerDevice_optional AngleAndComsumerDevice_;
};

class RealTimeType: public ::xml_schema::type
{
  public:
  // openLoop
  //
  typedef ::OpenLoopType openLoop_type;
  typedef ::xsd::cxx::tree::optional< openLoop_type > openLoop_optional;
  typedef ::xsd::cxx::tree::traits< openLoop_type, char > openLoop_traits;

  const openLoop_optional&
  openLoop () const;

  openLoop_optional&
  openLoop ();

  void
  openLoop (const openLoop_type& x);

  void
  openLoop (const openLoop_optional& x);

  void
  openLoop (::std::auto_ptr< openLoop_type > p);

  // hybrid
  //
  typedef ::HybridType hybrid_type;
  typedef ::xsd::cxx::tree::optional< hybrid_type > hybrid_optional;
  typedef ::xsd::cxx::tree::traits< hybrid_type, char > hybrid_traits;

  const hybrid_optional&
  hybrid () const;

  hybrid_optional&
  hybrid ();

  void
  hybrid (const hybrid_type& x);

  void
  hybrid (const hybrid_optional& x);

  void
  hybrid (::std::auto_ptr< hybrid_type > p);

  // Constructors.
  //
  RealTimeType ();

  RealTimeType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  RealTimeType (const RealTimeType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual RealTimeType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  RealTimeType&
  operator= (const RealTimeType& x);

  virtual 
  ~RealTimeType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  openLoop_optional openLoop_;
  hybrid_optional hybrid_;
};

class OnlineType: public ::xml_schema::type
{
  public:
  // Constructors.
  //
  OnlineType ();

  OnlineType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  OnlineType (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  OnlineType (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  OnlineType (const OnlineType& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual OnlineType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~OnlineType ();
};

class OfflineType: public ::xml_schema::type
{
  public:
  // Constructors.
  //
  OfflineType ();

  OfflineType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  OfflineType (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  OfflineType (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  OfflineType (const OfflineType& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  virtual OfflineType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~OfflineType ();
};

class CurvechoiceType: public ::xml_schema::type
{
  public:
  // online
  //
  typedef ::OnlineType online_type;
  typedef ::xsd::cxx::tree::optional< online_type > online_optional;
  typedef ::xsd::cxx::tree::traits< online_type, char > online_traits;

  const online_optional&
  online () const;

  online_optional&
  online ();

  void
  online (const online_type& x);

  void
  online (const online_optional& x);

  void
  online (::std::auto_ptr< online_type > p);

  // offline
  //
  typedef ::OfflineType offline_type;
  typedef ::xsd::cxx::tree::optional< offline_type > offline_optional;
  typedef ::xsd::cxx::tree::traits< offline_type, char > offline_traits;

  const offline_optional&
  offline () const;

  offline_optional&
  offline ();

  void
  offline (const offline_type& x);

  void
  offline (const offline_optional& x);

  void
  offline (::std::auto_ptr< offline_type > p);

  // Constructors.
  //
  CurvechoiceType ();

  CurvechoiceType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  CurvechoiceType (const CurvechoiceType& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  virtual CurvechoiceType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  CurvechoiceType&
  operator= (const CurvechoiceType& x);

  virtual 
  ~CurvechoiceType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  online_optional online_;
  offline_optional offline_;
};

class TypeType: public ::xml_schema::type
{
  public:
  // openLoop
  //
  typedef ::OpenLoopType openLoop_type;
  typedef ::xsd::cxx::tree::optional< openLoop_type > openLoop_optional;
  typedef ::xsd::cxx::tree::traits< openLoop_type, char > openLoop_traits;

  const openLoop_optional&
  openLoop () const;

  openLoop_optional&
  openLoop ();

  void
  openLoop (const openLoop_type& x);

  void
  openLoop (const openLoop_optional& x);

  void
  openLoop (::std::auto_ptr< openLoop_type > p);

  // hybrid
  //
  typedef ::HybridType hybrid_type;
  typedef ::xsd::cxx::tree::optional< hybrid_type > hybrid_optional;
  typedef ::xsd::cxx::tree::traits< hybrid_type, char > hybrid_traits;

  const hybrid_optional&
  hybrid () const;

  hybrid_optional&
  hybrid ();

  void
  hybrid (const hybrid_type& x);

  void
  hybrid (const hybrid_optional& x);

  void
  hybrid (::std::auto_ptr< hybrid_type > p);

  // realTime
  //
  typedef ::RealTimeType realTime_type;
  typedef ::xsd::cxx::tree::optional< realTime_type > realTime_optional;
  typedef ::xsd::cxx::tree::traits< realTime_type, char > realTime_traits;

  const realTime_optional&
  realTime () const;

  realTime_optional&
  realTime ();

  void
  realTime (const realTime_type& x);

  void
  realTime (const realTime_optional& x);

  void
  realTime (::std::auto_ptr< realTime_type > p);

  // Constructors.
  //
  TypeType ();

  TypeType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  TypeType (const TypeType& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual TypeType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  TypeType&
  operator= (const TypeType& x);

  virtual 
  ~TypeType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  openLoop_optional openLoop_;
  hybrid_optional hybrid_;
  realTime_optional realTime_;
};

class NMSModelType: public ::xml_schema::type
{
  public:
  // type
  //
  typedef ::TypeType type_type;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_type&
  type () const;

  type_type&
  type ();

  void
  type (const type_type& x);

  void
  type (::std::auto_ptr< type_type > p);

  // tendon
  //
  typedef ::TendonType tendon_type;
  typedef ::xsd::cxx::tree::traits< tendon_type, char > tendon_traits;

  const tendon_type&
  tendon () const;

  tendon_type&
  tendon ();

  void
  tendon (const tendon_type& x);

  void
  tendon (::std::auto_ptr< tendon_type > p);

  // activation
  //
  typedef ::ActivationType activation_type;
  typedef ::xsd::cxx::tree::traits< activation_type, char > activation_traits;

  const activation_type&
  activation () const;

  activation_type&
  activation ();

  void
  activation (const activation_type& x);

  void
  activation (::std::auto_ptr< activation_type > p);

  // curve
  //
  typedef ::CurvechoiceType curve_type;
  typedef ::xsd::cxx::tree::traits< curve_type, char > curve_traits;

  const curve_type&
  curve () const;

  curve_type&
  curve ();

  void
  curve (const curve_type& x);

  void
  curve (::std::auto_ptr< curve_type > p);

  // Constructors.
  //
  NMSModelType (const type_type&,
                const tendon_type&,
                const activation_type&,
                const curve_type&);

  NMSModelType (::std::auto_ptr< type_type >,
                ::std::auto_ptr< tendon_type >,
                ::std::auto_ptr< activation_type >,
                ::std::auto_ptr< curve_type >);

  NMSModelType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  NMSModelType (const NMSModelType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual NMSModelType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  NMSModelType&
  operator= (const NMSModelType& x);

  virtual 
  ~NMSModelType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< type_type > type_;
  ::xsd::cxx::tree::one< tendon_type > tendon_;
  ::xsd::cxx::tree::one< activation_type > activation_;
  ::xsd::cxx::tree::one< curve_type > curve_;
};

class ElaboratedDoFsType: public ::xml_schema::simple_type,
  public ::xsd::cxx::tree::list< ::xml_schema::string, char >
{
  public:
  ElaboratedDoFsType ();

  ElaboratedDoFsType (size_type n, const ::xml_schema::string& x);

  template < typename I >
  ElaboratedDoFsType (const I& begin, const I& end)
  : ::xsd::cxx::tree::list< ::xml_schema::string, char > (begin, end, this)
  {
  }

  ElaboratedDoFsType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  ElaboratedDoFsType (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  ElaboratedDoFsType (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  ElaboratedDoFsType (const ElaboratedDoFsType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  virtual ElaboratedDoFsType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~ElaboratedDoFsType ();
};

class ExecutionElementType: public ::xml_schema::type
{
  public:
  // Constructors.
  //
  ExecutionElementType ();

  ExecutionElementType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  ExecutionElementType (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  ExecutionElementType (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  ExecutionElementType (const ExecutionElementType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  virtual ExecutionElementType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~ExecutionElementType ();
};

class FileType: public ::xml_schema::type
{
  public:
  // Constructors.
  //
  FileType ();

  FileType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  FileType (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  FileType (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  FileType (const FileType& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual FileType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~FileType ();
};

class LoggingType: public ::xml_schema::type
{
  public:
  // txt
  //
  typedef ::FileType txt_type;
  typedef ::xsd::cxx::tree::optional< txt_type > txt_optional;
  typedef ::xsd::cxx::tree::traits< txt_type, char > txt_traits;

  const txt_optional&
  txt () const;

  txt_optional&
  txt ();

  void
  txt (const txt_type& x);

  void
  txt (const txt_optional& x);

  void
  txt (::std::auto_ptr< txt_type > p);

  // csv
  //
  typedef ::FileType csv_type;
  typedef ::xsd::cxx::tree::optional< csv_type > csv_optional;
  typedef ::xsd::cxx::tree::traits< csv_type, char > csv_traits;

  const csv_optional&
  csv () const;

  csv_optional&
  csv ();

  void
  csv (const csv_type& x);

  void
  csv (const csv_optional& x);

  void
  csv (::std::auto_ptr< csv_type > p);

  // mot
  //
  typedef ::FileType mot_type;
  typedef ::xsd::cxx::tree::optional< mot_type > mot_optional;
  typedef ::xsd::cxx::tree::traits< mot_type, char > mot_traits;

  const mot_optional&
  mot () const;

  mot_optional&
  mot ();

  void
  mot (const mot_type& x);

  void
  mot (const mot_optional& x);

  void
  mot (::std::auto_ptr< mot_type > p);

  // Constructors.
  //
  LoggingType ();

  LoggingType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  LoggingType (const LoggingType& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  virtual LoggingType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  LoggingType&
  operator= (const LoggingType& x);

  virtual 
  ~LoggingType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  txt_optional txt_;
  csv_optional csv_;
  mot_optional mot_;
};

class ExecutionType: public ::xml_schema::type
{
  public:
  // NMSmodel
  //
  typedef ::NMSModelType NMSmodel_type;
  typedef ::xsd::cxx::tree::traits< NMSmodel_type, char > NMSmodel_traits;

  const NMSmodel_type&
  NMSmodel () const;

  NMSmodel_type&
  NMSmodel ();

  void
  NMSmodel (const NMSmodel_type& x);

  void
  NMSmodel (::std::auto_ptr< NMSmodel_type > p);

  // samplingFrequency
  //
  typedef ::xml_schema::int_ samplingFrequency_type;
  typedef ::xsd::cxx::tree::optional< samplingFrequency_type > samplingFrequency_optional;
  typedef ::xsd::cxx::tree::traits< samplingFrequency_type, char > samplingFrequency_traits;

  const samplingFrequency_optional&
  samplingFrequency () const;

  samplingFrequency_optional&
  samplingFrequency ();

  void
  samplingFrequency (const samplingFrequency_type& x);

  void
  samplingFrequency (const samplingFrequency_optional& x);

  // elaboratedDoFs
  //
  typedef ::ElaboratedDoFsType elaboratedDoFs_type;
  typedef ::xsd::cxx::tree::optional< elaboratedDoFs_type > elaboratedDoFs_optional;
  typedef ::xsd::cxx::tree::traits< elaboratedDoFs_type, char > elaboratedDoFs_traits;

  const elaboratedDoFs_optional&
  elaboratedDoFs () const;

  elaboratedDoFs_optional&
  elaboratedDoFs ();

  void
  elaboratedDoFs (const elaboratedDoFs_type& x);

  void
  elaboratedDoFs (const elaboratedDoFs_optional& x);

  void
  elaboratedDoFs (::std::auto_ptr< elaboratedDoFs_type > p);

  // logging
  //
  typedef ::LoggingType logging_type;
  typedef ::xsd::cxx::tree::optional< logging_type > logging_optional;
  typedef ::xsd::cxx::tree::traits< logging_type, char > logging_traits;

  const logging_optional&
  logging () const;

  logging_optional&
  logging ();

  void
  logging (const logging_type& x);

  void
  logging (const logging_optional& x);

  void
  logging (::std::auto_ptr< logging_type > p);

  // ConsumerPlugin
  //
  typedef ::DevicePluginType ConsumerPlugin_type;
  typedef ::xsd::cxx::tree::traits< ConsumerPlugin_type, char > ConsumerPlugin_traits;

  const ConsumerPlugin_type&
  ConsumerPlugin () const;

  ConsumerPlugin_type&
  ConsumerPlugin ();

  void
  ConsumerPlugin (const ConsumerPlugin_type& x);

  void
  ConsumerPlugin (::std::auto_ptr< ConsumerPlugin_type > p);

  // NameOfSubject
  //
  typedef ::xml_schema::string NameOfSubject_type;
  typedef ::xsd::cxx::tree::traits< NameOfSubject_type, char > NameOfSubject_traits;

  const NameOfSubject_type&
  NameOfSubject () const;

  NameOfSubject_type&
  NameOfSubject ();

  void
  NameOfSubject (const NameOfSubject_type& x);

  void
  NameOfSubject (::std::auto_ptr< NameOfSubject_type > p);

  // Constructors.
  //
  ExecutionType (const NMSmodel_type&,
                 const ConsumerPlugin_type&,
                 const NameOfSubject_type&);

  ExecutionType (::std::auto_ptr< NMSmodel_type >,
                 ::std::auto_ptr< ConsumerPlugin_type >,
                 const NameOfSubject_type&);

  ExecutionType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  ExecutionType (const ExecutionType& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  virtual ExecutionType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ExecutionType&
  operator= (const ExecutionType& x);

  virtual 
  ~ExecutionType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< NMSmodel_type > NMSmodel_;
  samplingFrequency_optional samplingFrequency_;
  elaboratedDoFs_optional elaboratedDoFs_;
  logging_optional logging_;
  ::xsd::cxx::tree::one< ConsumerPlugin_type > ConsumerPlugin_;
  ::xsd::cxx::tree::one< NameOfSubject_type > NameOfSubject_;
};

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

// Parse a URI or a local file.
//

::std::auto_ptr< ::ExecutionType >
execution (const ::std::string& uri,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::ExecutionType >
execution (const ::std::string& uri,
           ::xml_schema::error_handler& eh,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::ExecutionType >
execution (const ::std::string& uri,
           ::xercesc::DOMErrorHandler& eh,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse std::istream.
//

::std::auto_ptr< ::ExecutionType >
execution (::std::istream& is,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::ExecutionType >
execution (::std::istream& is,
           ::xml_schema::error_handler& eh,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::ExecutionType >
execution (::std::istream& is,
           ::xercesc::DOMErrorHandler& eh,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::ExecutionType >
execution (::std::istream& is,
           const ::std::string& id,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::ExecutionType >
execution (::std::istream& is,
           const ::std::string& id,
           ::xml_schema::error_handler& eh,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::ExecutionType >
execution (::std::istream& is,
           const ::std::string& id,
           ::xercesc::DOMErrorHandler& eh,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::InputSource.
//

::std::auto_ptr< ::ExecutionType >
execution (::xercesc::InputSource& is,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::ExecutionType >
execution (::xercesc::InputSource& is,
           ::xml_schema::error_handler& eh,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::ExecutionType >
execution (::xercesc::InputSource& is,
           ::xercesc::DOMErrorHandler& eh,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::DOMDocument.
//

::std::auto_ptr< ::ExecutionType >
execution (const ::xercesc::DOMDocument& d,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::ExecutionType >
execution (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

void
operator<< (::xercesc::DOMElement&, const TendonElementType&);

void
operator<< (::xercesc::DOMAttr&, const TendonElementType&);

void
operator<< (::xml_schema::list_stream&,
            const TendonElementType&);

void
operator<< (::xercesc::DOMElement&, const TendonType&);

void
operator<< (::xercesc::DOMElement&, const ActivationElementType&);

void
operator<< (::xercesc::DOMAttr&, const ActivationElementType&);

void
operator<< (::xml_schema::list_stream&,
            const ActivationElementType&);

void
operator<< (::xercesc::DOMElement&, const ActivationType&);

void
operator<< (::xercesc::DOMElement&, const HybridAlgorithmSimulatedAnnealingType&);

void
operator<< (::xercesc::DOMElement&, const HybridAlgorithmType&);

void
operator<< (::xercesc::DOMElement&, const OpenLoopType&);

void
operator<< (::xercesc::DOMAttr&, const OpenLoopType&);

void
operator<< (::xml_schema::list_stream&,
            const OpenLoopType&);

void
operator<< (::xercesc::DOMElement&, const MuscleListType&);

void
operator<< (::xercesc::DOMAttr&, const MuscleListType&);

void
operator<< (::xml_schema::list_stream&,
            const MuscleListType&);

void
operator<< (::xercesc::DOMElement&, const HybridType&);

void
operator<< (::xercesc::DOMElement&, const DevicePluginType&);

void
operator<< (::xercesc::DOMElement&, const RealTimeType&);

void
operator<< (::xercesc::DOMElement&, const OnlineType&);

void
operator<< (::xercesc::DOMAttr&, const OnlineType&);

void
operator<< (::xml_schema::list_stream&,
            const OnlineType&);

void
operator<< (::xercesc::DOMElement&, const OfflineType&);

void
operator<< (::xercesc::DOMAttr&, const OfflineType&);

void
operator<< (::xml_schema::list_stream&,
            const OfflineType&);

void
operator<< (::xercesc::DOMElement&, const CurvechoiceType&);

void
operator<< (::xercesc::DOMElement&, const TypeType&);

void
operator<< (::xercesc::DOMElement&, const NMSModelType&);

void
operator<< (::xercesc::DOMElement&, const ElaboratedDoFsType&);

void
operator<< (::xercesc::DOMAttr&, const ElaboratedDoFsType&);

void
operator<< (::xml_schema::list_stream&,
            const ElaboratedDoFsType&);

void
operator<< (::xercesc::DOMElement&, const ExecutionElementType&);

void
operator<< (::xercesc::DOMAttr&, const ExecutionElementType&);

void
operator<< (::xml_schema::list_stream&,
            const ExecutionElementType&);

void
operator<< (::xercesc::DOMElement&, const FileType&);

void
operator<< (::xercesc::DOMAttr&, const FileType&);

void
operator<< (::xml_schema::list_stream&,
            const FileType&);

void
operator<< (::xercesc::DOMElement&, const LoggingType&);

void
operator<< (::xercesc::DOMElement&, const ExecutionType&);

// Serialize to std::ostream.
//

void
execution (::std::ostream& os,
           const ::ExecutionType& x, 
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           const ::std::string& e = "UTF-8",
           ::xml_schema::flags f = 0);

void
execution (::std::ostream& os,
           const ::ExecutionType& x, 
           ::xml_schema::error_handler& eh,
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           const ::std::string& e = "UTF-8",
           ::xml_schema::flags f = 0);

void
execution (::std::ostream& os,
           const ::ExecutionType& x, 
           ::xercesc::DOMErrorHandler& eh,
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           const ::std::string& e = "UTF-8",
           ::xml_schema::flags f = 0);

// Serialize to xercesc::XMLFormatTarget.
//

void
execution (::xercesc::XMLFormatTarget& ft,
           const ::ExecutionType& x, 
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           const ::std::string& e = "UTF-8",
           ::xml_schema::flags f = 0);

void
execution (::xercesc::XMLFormatTarget& ft,
           const ::ExecutionType& x, 
           ::xml_schema::error_handler& eh,
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           const ::std::string& e = "UTF-8",
           ::xml_schema::flags f = 0);

void
execution (::xercesc::XMLFormatTarget& ft,
           const ::ExecutionType& x, 
           ::xercesc::DOMErrorHandler& eh,
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           const ::std::string& e = "UTF-8",
           ::xml_schema::flags f = 0);

// Serialize to an existing xercesc::DOMDocument.
//

void
execution (::xercesc::DOMDocument& d,
           const ::ExecutionType& x,
           ::xml_schema::flags f = 0);

// Serialize to a new xercesc::DOMDocument.
//

::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
execution (const ::ExecutionType& x, 
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           ::xml_schema::flags f = 0);

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // EXECUTION_HXX
