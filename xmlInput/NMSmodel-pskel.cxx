// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "NMSmodel-pskel.hxx"

// MuscleType_pskel
//

void MuscleType_pskel::
name_parser (::xml_schema::string_pskel& p)
{
  this->name_parser_ = &p;
}

void MuscleType_pskel::
C1_parser (::xml_schema::double_pskel& p)
{
  this->C1_parser_ = &p;
}

void MuscleType_pskel::
C2_parser (::xml_schema::double_pskel& p)
{
  this->C2_parser_ = &p;
}

void MuscleType_pskel::
shapeFactor_parser (::xml_schema::double_pskel& p)
{
  this->shapeFactor_parser_ = &p;
}

void MuscleType_pskel::
optimalFiberLength_parser (::xml_schema::double_pskel& p)
{
  this->optimalFiberLength_parser_ = &p;
}

void MuscleType_pskel::
pennationAngle_parser (::xml_schema::double_pskel& p)
{
  this->pennationAngle_parser_ = &p;
}

void MuscleType_pskel::
tendonSlackLength_parser (::xml_schema::double_pskel& p)
{
  this->tendonSlackLength_parser_ = &p;
}

void MuscleType_pskel::
maxIsometricForce_parser (::xml_schema::double_pskel& p)
{
  this->maxIsometricForce_parser_ = &p;
}

void MuscleType_pskel::
strengthCoefficient_parser (::xml_schema::double_pskel& p)
{
  this->strengthCoefficient_parser_ = &p;
}

void MuscleType_pskel::
parsers (::xml_schema::string_pskel& name,
         ::xml_schema::double_pskel& C1,
         ::xml_schema::double_pskel& C2,
         ::xml_schema::double_pskel& shapeFactor,
         ::xml_schema::double_pskel& optimalFiberLength,
         ::xml_schema::double_pskel& pennationAngle,
         ::xml_schema::double_pskel& tendonSlackLength,
         ::xml_schema::double_pskel& maxIsometricForce,
         ::xml_schema::double_pskel& strengthCoefficient)
{
  this->name_parser_ = &name;
  this->C1_parser_ = &C1;
  this->C2_parser_ = &C2;
  this->shapeFactor_parser_ = &shapeFactor;
  this->optimalFiberLength_parser_ = &optimalFiberLength;
  this->pennationAngle_parser_ = &pennationAngle;
  this->tendonSlackLength_parser_ = &tendonSlackLength;
  this->maxIsometricForce_parser_ = &maxIsometricForce;
  this->strengthCoefficient_parser_ = &strengthCoefficient;
}

MuscleType_pskel::
MuscleType_pskel ()
: name_parser_ (0),
  C1_parser_ (0),
  C2_parser_ (0),
  shapeFactor_parser_ (0),
  optimalFiberLength_parser_ (0),
  pennationAngle_parser_ (0),
  tendonSlackLength_parser_ (0),
  maxIsometricForce_parser_ (0),
  strengthCoefficient_parser_ (0)
{
}

// MusclesType_pskel
//

void MusclesType_pskel::
muscle_parser (::MuscleType_pskel& p)
{
  this->muscle_parser_ = &p;
}

void MusclesType_pskel::
parsers (::MuscleType_pskel& muscle)
{
  this->muscle_parser_ = &muscle;
}

MusclesType_pskel::
MusclesType_pskel ()
: muscle_parser_ (0)
{
}

// MuscleSequenceType_pskel
//

void MuscleSequenceType_pskel::
item_parser (::xml_schema::string_pskel& item)
{
  this->_xsd_item_ = &item;
}

void MuscleSequenceType_pskel::
parsers (::xml_schema::string_pskel& item)
{
  this->_xsd_item_ = &item;
}

MuscleSequenceType_pskel::
MuscleSequenceType_pskel ()
: _xsd_item_ (0)
{
}

// ChannelType_pskel
//

void ChannelType_pskel::
name_parser (::xml_schema::string_pskel& p)
{
  this->name_parser_ = &p;
}

void ChannelType_pskel::
muscleSequence_parser (::MuscleSequenceType_pskel& p)
{
  this->muscleSequence_parser_ = &p;
}

void ChannelType_pskel::
parsers (::xml_schema::string_pskel& name,
         ::MuscleSequenceType_pskel& muscleSequence)
{
  this->name_parser_ = &name;
  this->muscleSequence_parser_ = &muscleSequence;
}

ChannelType_pskel::
ChannelType_pskel ()
: name_parser_ (0),
  muscleSequence_parser_ (0)
{
}

// ChannelsType_pskel
//

void ChannelsType_pskel::
Channel_parser (::ChannelType_pskel& p)
{
  this->Channel_parser_ = &p;
}

void ChannelsType_pskel::
parsers (::ChannelType_pskel& Channel)
{
  this->Channel_parser_ = &Channel;
}

ChannelsType_pskel::
ChannelsType_pskel ()
: Channel_parser_ (0)
{
}

// DoFType_pskel
//

void DoFType_pskel::
name_parser (::xml_schema::string_pskel& p)
{
  this->name_parser_ = &p;
}

void DoFType_pskel::
muscleSequence_parser (::MuscleSequenceType_pskel& p)
{
  this->muscleSequence_parser_ = &p;
}

void DoFType_pskel::
parsers (::xml_schema::string_pskel& name,
         ::MuscleSequenceType_pskel& muscleSequence)
{
  this->name_parser_ = &name;
  this->muscleSequence_parser_ = &muscleSequence;
}

DoFType_pskel::
DoFType_pskel ()
: name_parser_ (0),
  muscleSequence_parser_ (0)
{
}

// DoFsType_pskel
//

void DoFsType_pskel::
DoF_parser (::DoFType_pskel& p)
{
  this->DoF_parser_ = &p;
}

void DoFsType_pskel::
parsers (::DoFType_pskel& DoF)
{
  this->DoF_parser_ = &DoF;
}

DoFsType_pskel::
DoFsType_pskel ()
: DoF_parser_ (0)
{
}

// PointsSequenceType_pskel
//

void PointsSequenceType_pskel::
item_parser (::xml_schema::double_pskel& item)
{
  this->_xsd_item_ = &item;
}

void PointsSequenceType_pskel::
parsers (::xml_schema::double_pskel& item)
{
  this->_xsd_item_ = &item;
}

PointsSequenceType_pskel::
PointsSequenceType_pskel ()
: _xsd_item_ (0)
{
}

// CurveType_pskel
//

void CurveType_pskel::
name_parser (::xml_schema::string_pskel& p)
{
  this->name_parser_ = &p;
}

void CurveType_pskel::
xPoints_parser (::PointsSequenceType_pskel& p)
{
  this->xPoints_parser_ = &p;
}

void CurveType_pskel::
yPoints_parser (::PointsSequenceType_pskel& p)
{
  this->yPoints_parser_ = &p;
}

void CurveType_pskel::
parsers (::xml_schema::string_pskel& name,
         ::PointsSequenceType_pskel& xPoints,
         ::PointsSequenceType_pskel& yPoints)
{
  this->name_parser_ = &name;
  this->xPoints_parser_ = &xPoints;
  this->yPoints_parser_ = &yPoints;
}

CurveType_pskel::
CurveType_pskel ()
: name_parser_ (0),
  xPoints_parser_ (0),
  yPoints_parser_ (0)
{
}

// MuscleDefaultType_pskel
//

void MuscleDefaultType_pskel::
percentageChange_parser (::xml_schema::double_pskel& p)
{
  this->percentageChange_parser_ = &p;
}

void MuscleDefaultType_pskel::
damping_parser (::xml_schema::double_pskel& p)
{
  this->damping_parser_ = &p;
}

void MuscleDefaultType_pskel::
Curve_parser (::CurveType_pskel& p)
{
  this->Curve_parser_ = &p;
}

void MuscleDefaultType_pskel::
parsers (::xml_schema::double_pskel& percentageChange,
         ::xml_schema::double_pskel& damping,
         ::CurveType_pskel& Curve)
{
  this->percentageChange_parser_ = &percentageChange;
  this->damping_parser_ = &damping;
  this->Curve_parser_ = &Curve;
}

MuscleDefaultType_pskel::
MuscleDefaultType_pskel ()
: percentageChange_parser_ (0),
  damping_parser_ (0),
  Curve_parser_ (0)
{
}

// NMSmodelType_pskel
//

void NMSmodelType_pskel::
muscleDefault_parser (::MuscleDefaultType_pskel& p)
{
  this->muscleDefault_parser_ = &p;
}

void NMSmodelType_pskel::
muscles_parser (::MusclesType_pskel& p)
{
  this->muscles_parser_ = &p;
}

void NMSmodelType_pskel::
DoFs_parser (::DoFsType_pskel& p)
{
  this->DoFs_parser_ = &p;
}

void NMSmodelType_pskel::
Channels_parser (::ChannelsType_pskel& p)
{
  this->Channels_parser_ = &p;
}

void NMSmodelType_pskel::
parsers (::MuscleDefaultType_pskel& muscleDefault,
         ::MusclesType_pskel& muscles,
         ::DoFsType_pskel& DoFs,
         ::ChannelsType_pskel& Channels)
{
  this->muscleDefault_parser_ = &muscleDefault;
  this->muscles_parser_ = &muscles;
  this->DoFs_parser_ = &DoFs;
  this->Channels_parser_ = &Channels;
}

NMSmodelType_pskel::
NMSmodelType_pskel ()
: muscleDefault_parser_ (0),
  muscles_parser_ (0),
  DoFs_parser_ (0),
  Channels_parser_ (0)
{
}

// MuscleType_pskel
//

void MuscleType_pskel::
name (const ::std::string&)
{
}

void MuscleType_pskel::
C1 (double)
{
}

void MuscleType_pskel::
C2 (double)
{
}

void MuscleType_pskel::
shapeFactor (double)
{
}

void MuscleType_pskel::
optimalFiberLength (double)
{
}

void MuscleType_pskel::
pennationAngle (double)
{
}

void MuscleType_pskel::
tendonSlackLength (double)
{
}

void MuscleType_pskel::
maxIsometricForce (double)
{
}

void MuscleType_pskel::
strengthCoefficient (double)
{
}

void MuscleType_pskel::
post_MuscleType ()
{
}

bool MuscleType_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "name" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->name_parser_;

    if (this->name_parser_)
      this->name_parser_->pre ();

    return true;
  }

  if (n == "C1" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->C1_parser_;

    if (this->C1_parser_)
      this->C1_parser_->pre ();

    return true;
  }

  if (n == "C2" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->C2_parser_;

    if (this->C2_parser_)
      this->C2_parser_->pre ();

    return true;
  }

  if (n == "shapeFactor" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->shapeFactor_parser_;

    if (this->shapeFactor_parser_)
      this->shapeFactor_parser_->pre ();

    return true;
  }

  if (n == "optimalFiberLength" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->optimalFiberLength_parser_;

    if (this->optimalFiberLength_parser_)
      this->optimalFiberLength_parser_->pre ();

    return true;
  }

  if (n == "pennationAngle" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->pennationAngle_parser_;

    if (this->pennationAngle_parser_)
      this->pennationAngle_parser_->pre ();

    return true;
  }

  if (n == "tendonSlackLength" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->tendonSlackLength_parser_;

    if (this->tendonSlackLength_parser_)
      this->tendonSlackLength_parser_->pre ();

    return true;
  }

  if (n == "maxIsometricForce" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->maxIsometricForce_parser_;

    if (this->maxIsometricForce_parser_)
      this->maxIsometricForce_parser_->pre ();

    return true;
  }

  if (n == "strengthCoefficient" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->strengthCoefficient_parser_;

    if (this->strengthCoefficient_parser_)
      this->strengthCoefficient_parser_->pre ();

    return true;
  }

  return false;
}

bool MuscleType_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "name" && ns.empty ())
  {
    if (this->name_parser_)
      this->name (this->name_parser_->post_string ());

    return true;
  }

  if (n == "C1" && ns.empty ())
  {
    if (this->C1_parser_)
      this->C1 (this->C1_parser_->post_double ());

    return true;
  }

  if (n == "C2" && ns.empty ())
  {
    if (this->C2_parser_)
      this->C2 (this->C2_parser_->post_double ());

    return true;
  }

  if (n == "shapeFactor" && ns.empty ())
  {
    if (this->shapeFactor_parser_)
      this->shapeFactor (this->shapeFactor_parser_->post_double ());

    return true;
  }

  if (n == "optimalFiberLength" && ns.empty ())
  {
    if (this->optimalFiberLength_parser_)
      this->optimalFiberLength (this->optimalFiberLength_parser_->post_double ());

    return true;
  }

  if (n == "pennationAngle" && ns.empty ())
  {
    if (this->pennationAngle_parser_)
      this->pennationAngle (this->pennationAngle_parser_->post_double ());

    return true;
  }

  if (n == "tendonSlackLength" && ns.empty ())
  {
    if (this->tendonSlackLength_parser_)
      this->tendonSlackLength (this->tendonSlackLength_parser_->post_double ());

    return true;
  }

  if (n == "maxIsometricForce" && ns.empty ())
  {
    if (this->maxIsometricForce_parser_)
      this->maxIsometricForce (this->maxIsometricForce_parser_->post_double ());

    return true;
  }

  if (n == "strengthCoefficient" && ns.empty ())
  {
    if (this->strengthCoefficient_parser_)
      this->strengthCoefficient (this->strengthCoefficient_parser_->post_double ());

    return true;
  }

  return false;
}

// MusclesType_pskel
//

void MusclesType_pskel::
muscle ()
{
}

void MusclesType_pskel::
post_MusclesType ()
{
}

bool MusclesType_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "muscle" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->muscle_parser_;

    if (this->muscle_parser_)
      this->muscle_parser_->pre ();

    return true;
  }

  return false;
}

bool MusclesType_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "muscle" && ns.empty ())
  {
    if (this->muscle_parser_)
    {
      this->muscle_parser_->post_MuscleType ();
      this->muscle ();
    }

    return true;
  }

  return false;
}

// MuscleSequenceType_pskel
//

void MuscleSequenceType_pskel::
item (const ::std::string&)
{
}

void MuscleSequenceType_pskel::
post_MuscleSequenceType ()
{
}

void MuscleSequenceType_pskel::
_xsd_parse_item (const ::xml_schema::ro_string& v)
{
  if (this->_xsd_item_)
  {
    this->_xsd_item_->pre ();
    this->_xsd_item_->_pre_impl ();
    this->_xsd_item_->_characters (v);
    this->_xsd_item_->_post_impl ();
    this->item (this->_xsd_item_->post_string ());
  }
}

// ChannelType_pskel
//

void ChannelType_pskel::
name (const ::std::string&)
{
}

void ChannelType_pskel::
muscleSequence ()
{
}

void ChannelType_pskel::
post_ChannelType ()
{
}

bool ChannelType_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "name" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->name_parser_;

    if (this->name_parser_)
      this->name_parser_->pre ();

    return true;
  }

  if (n == "muscleSequence" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->muscleSequence_parser_;

    if (this->muscleSequence_parser_)
      this->muscleSequence_parser_->pre ();

    return true;
  }

  return false;
}

bool ChannelType_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "name" && ns.empty ())
  {
    if (this->name_parser_)
      this->name (this->name_parser_->post_string ());

    return true;
  }

  if (n == "muscleSequence" && ns.empty ())
  {
    if (this->muscleSequence_parser_)
    {
      this->muscleSequence_parser_->post_MuscleSequenceType ();
      this->muscleSequence ();
    }

    return true;
  }

  return false;
}

// ChannelsType_pskel
//

void ChannelsType_pskel::
Channel ()
{
}

void ChannelsType_pskel::
post_ChannelsType ()
{
}

bool ChannelsType_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "Channel" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->Channel_parser_;

    if (this->Channel_parser_)
      this->Channel_parser_->pre ();

    return true;
  }

  return false;
}

bool ChannelsType_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "Channel" && ns.empty ())
  {
    if (this->Channel_parser_)
    {
      this->Channel_parser_->post_ChannelType ();
      this->Channel ();
    }

    return true;
  }

  return false;
}

// DoFType_pskel
//

void DoFType_pskel::
name (const ::std::string&)
{
}

void DoFType_pskel::
muscleSequence ()
{
}

void DoFType_pskel::
post_DoFType ()
{
}

bool DoFType_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "name" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->name_parser_;

    if (this->name_parser_)
      this->name_parser_->pre ();

    return true;
  }

  if (n == "muscleSequence" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->muscleSequence_parser_;

    if (this->muscleSequence_parser_)
      this->muscleSequence_parser_->pre ();

    return true;
  }

  return false;
}

bool DoFType_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "name" && ns.empty ())
  {
    if (this->name_parser_)
      this->name (this->name_parser_->post_string ());

    return true;
  }

  if (n == "muscleSequence" && ns.empty ())
  {
    if (this->muscleSequence_parser_)
    {
      this->muscleSequence_parser_->post_MuscleSequenceType ();
      this->muscleSequence ();
    }

    return true;
  }

  return false;
}

// DoFsType_pskel
//

void DoFsType_pskel::
DoF ()
{
}

void DoFsType_pskel::
post_DoFsType ()
{
}

bool DoFsType_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "DoF" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->DoF_parser_;

    if (this->DoF_parser_)
      this->DoF_parser_->pre ();

    return true;
  }

  return false;
}

bool DoFsType_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "DoF" && ns.empty ())
  {
    if (this->DoF_parser_)
    {
      this->DoF_parser_->post_DoFType ();
      this->DoF ();
    }

    return true;
  }

  return false;
}

// PointsSequenceType_pskel
//

void PointsSequenceType_pskel::
item (double)
{
}

void PointsSequenceType_pskel::
post_PointsSequenceType ()
{
}

void PointsSequenceType_pskel::
_xsd_parse_item (const ::xml_schema::ro_string& v)
{
  if (this->_xsd_item_)
  {
    this->_xsd_item_->pre ();
    this->_xsd_item_->_pre_impl ();
    this->_xsd_item_->_characters (v);
    this->_xsd_item_->_post_impl ();
    this->item (this->_xsd_item_->post_double ());
  }
}

// CurveType_pskel
//

void CurveType_pskel::
name (const ::std::string&)
{
}

void CurveType_pskel::
xPoints ()
{
}

void CurveType_pskel::
yPoints ()
{
}

void CurveType_pskel::
post_CurveType ()
{
}

bool CurveType_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "name" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->name_parser_;

    if (this->name_parser_)
      this->name_parser_->pre ();

    return true;
  }

  if (n == "xPoints" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->xPoints_parser_;

    if (this->xPoints_parser_)
      this->xPoints_parser_->pre ();

    return true;
  }

  if (n == "yPoints" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->yPoints_parser_;

    if (this->yPoints_parser_)
      this->yPoints_parser_->pre ();

    return true;
  }

  return false;
}

bool CurveType_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "name" && ns.empty ())
  {
    if (this->name_parser_)
      this->name (this->name_parser_->post_string ());

    return true;
  }

  if (n == "xPoints" && ns.empty ())
  {
    if (this->xPoints_parser_)
    {
      this->xPoints_parser_->post_PointsSequenceType ();
      this->xPoints ();
    }

    return true;
  }

  if (n == "yPoints" && ns.empty ())
  {
    if (this->yPoints_parser_)
    {
      this->yPoints_parser_->post_PointsSequenceType ();
      this->yPoints ();
    }

    return true;
  }

  return false;
}

// MuscleDefaultType_pskel
//

void MuscleDefaultType_pskel::
percentageChange (double)
{
}

void MuscleDefaultType_pskel::
damping (double)
{
}

void MuscleDefaultType_pskel::
Curve ()
{
}

void MuscleDefaultType_pskel::
post_MuscleDefaultType ()
{
}

bool MuscleDefaultType_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "percentageChange" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->percentageChange_parser_;

    if (this->percentageChange_parser_)
      this->percentageChange_parser_->pre ();

    return true;
  }

  if (n == "damping" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->damping_parser_;

    if (this->damping_parser_)
      this->damping_parser_->pre ();

    return true;
  }

  if (n == "Curve" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->Curve_parser_;

    if (this->Curve_parser_)
      this->Curve_parser_->pre ();

    return true;
  }

  return false;
}

bool MuscleDefaultType_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "percentageChange" && ns.empty ())
  {
    if (this->percentageChange_parser_)
      this->percentageChange (this->percentageChange_parser_->post_double ());

    return true;
  }

  if (n == "damping" && ns.empty ())
  {
    if (this->damping_parser_)
      this->damping (this->damping_parser_->post_double ());

    return true;
  }

  if (n == "Curve" && ns.empty ())
  {
    if (this->Curve_parser_)
    {
      this->Curve_parser_->post_CurveType ();
      this->Curve ();
    }

    return true;
  }

  return false;
}

// NMSmodelType_pskel
//

void NMSmodelType_pskel::
muscleDefault ()
{
}

void NMSmodelType_pskel::
muscles ()
{
}

void NMSmodelType_pskel::
DoFs ()
{
}

void NMSmodelType_pskel::
Channels ()
{
}

void NMSmodelType_pskel::
post_NMSmodelType ()
{
}

bool NMSmodelType_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "muscleDefault" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->muscleDefault_parser_;

    if (this->muscleDefault_parser_)
      this->muscleDefault_parser_->pre ();

    return true;
  }

  if (n == "muscles" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->muscles_parser_;

    if (this->muscles_parser_)
      this->muscles_parser_->pre ();

    return true;
  }

  if (n == "DoFs" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->DoFs_parser_;

    if (this->DoFs_parser_)
      this->DoFs_parser_->pre ();

    return true;
  }

  if (n == "Channels" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->Channels_parser_;

    if (this->Channels_parser_)
      this->Channels_parser_->pre ();

    return true;
  }

  return false;
}

bool NMSmodelType_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "muscleDefault" && ns.empty ())
  {
    if (this->muscleDefault_parser_)
    {
      this->muscleDefault_parser_->post_MuscleDefaultType ();
      this->muscleDefault ();
    }

    return true;
  }

  if (n == "muscles" && ns.empty ())
  {
    if (this->muscles_parser_)
    {
      this->muscles_parser_->post_MusclesType ();
      this->muscles ();
    }

    return true;
  }

  if (n == "DoFs" && ns.empty ())
  {
    if (this->DoFs_parser_)
    {
      this->DoFs_parser_->post_DoFsType ();
      this->DoFs ();
    }

    return true;
  }

  if (n == "Channels" && ns.empty ())
  {
    if (this->Channels_parser_)
    {
      this->Channels_parser_->post_ChannelsType ();
      this->Channels ();
    }

    return true;
  }

  return false;
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

